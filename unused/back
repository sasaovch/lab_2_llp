%code requires {
  #include "ast.h"
}

%{
  #include <stdio.h>
  #include <stdlib.h>
  #include "parser.h"

  extern void yyerror (char const *);
  extern int yylex(void);

  extern FILE *yyin;
%}

%union {
  int integer;
  int boolean;
  double real;
  char *string;
  Node *node;
}

%token
    QUERY
    MUTATION
    BOOLEAN
    NULL_VALUE
    FIELD
    VARIABLE
    NUMBER
    STRING
    PARENTHESIS
    COLON
    EQUAL
    BRAKET_OPEN
    BRAKET_CLOSE
    CURLY_BRACE_OPEN
    CURLY_BRACE_CLOSE
    COMMA
    DOT
    EQUAL_OPERATOR
    LOWER_OPERATOR
    GREATER_OPERATOR
    GREATER_EQUAL
    LOWER_EQUAL
    NOT_EQUAL
    NOT
    OR
    AND
    INTEGER
    DOUBLE
    IDENTIFIER
    PLUS_OPERATION
    MINUS_OPERATION
    MULTIPLY_OPERATION
    DIVIDE_OPERATION
    RET
    DOUBLE_DOT

%type <string> IDENTIFIER
%type <real> DOUBLE
%type <integer> INTEGER
%type <boolean> BOOLEAN

%nterm <node> start 
      operation_definitions 
      operation_definition 
      query 
      mutation 
      eval 
      field_set 
      object
      objects
      opt_name 
      field 
      argument 
      expr 
      mul_expr 
      rel_expr 
      unary_expr 
      atomic_expr
      name_opt
      selection_set_opt
      selection_set
      selection_list
      selection
      arguments_opt
      argument_list
      arguments

%token <intval> LT GT EQ NE

%%

start:
  operation_definitions { printTree($$, 0, "operation_definitions" ); return 0; }
  | start RET { printTree($$, 0, "start" ); return 0; }
;

operation_definitions:
    operation_definition { $$ = $1; }
  | operation_definitions operation_definition { $$ = createNode("operation_definitions", 0, $1, $2); }
;

operation_definition:
  query { $$ = $1; }
  | mutation { $$ = $1; }
;

query:
  QUERY name_opt selection_set { $$ = createNode("query", 0, $2, $3); }
;

mutation:
  MUTATION name_opt selection_set { $$ = createNode("mutation", 0, $2, $3); }
;

name_opt: { $$ = NULL; }
  | FIELD { $$ = createNode("name_opt", 0, NULL, NULL);}

selection_set_opt:
   { $$ = NULL; }
  | selection_set
  ; 

selection_set:
  CURLY_BRACE_OPEN selection_list CURLY_BRACE_CLOSE { $$ = createNode("selection_set", 0, $2, NULL); }
  ;

selection_list:
  selection { $$ = $1; }
  | selection_list selection { $$ = createNode("selection_list", 0, $1, $2); }
  ;

selection:
  field { $$ = $1; }
  ;

field:
   FIELD arguments_opt selection_set_opt { Node *nd = createNode("tu", 0, $2, $3); Node *f = createNode("FIELD_field", 0, NULL, NULL); $$ = createNode("field", 0, f, nd); }
  | FIELD DOUBLE_DOT FIELD arguments_opt selection_set_opt { Node *f1 = createNode("f1", 0, NULL, NULL); Node *f2 = createNode("f2", 0, NULL, NULL); Node *nd = createNode(":", 0, f1, f2); $$ = createNode("field", 0, nd, $4); }
  ;

arguments_opt:  { $$ = NULL; }
  | arguments { $$ = $1; }
  ;

arguments:
  BRAKET_OPEN argument_list BRAKET_CLOSE { $$ = $2; }
  ;

argument_list:
    argument { $$ = $1; }
  | argument_list argument { $$ = createNode("argument_list", 0, $1, $2); }
  ;

argument:
  FIELD DOUBLE_DOT eval { Node *f1 = createNode("f1", 0, NULL, NULL); $$ = createNode("argument", 0, f1, $3); }
  ;

eval: 
      rel_expr { printTree($$, 0, "expr" ); return 0; }
    | eval RET { printTree($$, 0, "ret"); $$ = $1; return 0; }
    ;

rel_expr:
        expr                  { $$ = $1; }
    |  rel_expr LOWER_OPERATOR expr      { $$ = createNode("<", 0, $1, $3); }
    | rel_expr GREATER_OPERATOR expr      { $$ = createNode(">", 0, $1, $3);  }
    | rel_expr EQUAL_OPERATOR expr      { $$ = createNode("==", 0, $1, $3); }
    | rel_expr NOT_EQUAL expr      { $$ = createNode("!=", 0, $1, $3);  }
    ;

expr:
      mul_expr                    { $$ = $1; }
    | expr PLUS_OPERATION mul_expr           { $$ = createNode("+", 0, $1, $3); }
    | expr MINUS_OPERATION mul_expr           { $$ = createNode("-", 0, $1, $3); }
    ;

mul_expr:
      unary_expr                    { $$ = $1; }
    | mul_expr MULTIPLY_OPERATION unary_expr       { $$ = createNode("*", 0, $1, $3); }
    | mul_expr DIVIDE_OPERATION unary_expr       { $$ = createNode("/", 0, $1, $3); }
    ;

unary_expr:
      atomic_expr                 { $$ = $1; }
    ;

atomic_expr:
      BRAKET_OPEN expr BRAKET_CLOSE               { $$ = $2; }
    | DOUBLE                      { $$ = createNode("integer", $1, NULL, NULL); }
    | INTEGER                     { $$ = createNode("integer", $1, NULL, NULL); }
    ;


%%

void yyerror(const char *s) {
  fprintf(stderr, "error: %s\n", s);
}


int main(int argc, char *argv[]) {
  --argc;
  ++argv;
  if (argc == 0) {
    printf("Usage: ./parser <file.graphql>\n");
    return 1;
  }
  
  FILE *file = fopen(argv[0], "r");
  if (file == NULL) {
    printf("Unable to open file: %s\n", argv[0]);
    return 1;
  }
  yyin = file;
  if (yyparse()) {
    printf("Parsing failed\n");
  }
}